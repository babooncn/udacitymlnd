from environment.event import (SignalEvent, EventType)
from collections import deque
from AbstractIndicator import AbstractIndicator
import numpy as np
import random


def rsi(prices, period=14):
    """
    The Relative Strength Index (RSI) is a momentum oscillator.
    It oscillates between 0 and 100.
    It is considered overbought/oversold when it's over 70/below 30.
    Some traders use 80/20 to be on the safe side.
    RSI becomes more accurate as the calculation period (min_periods)
    increases.
    This can be lowered to increase sensitivity or raised to decrease
    sensitivity.
    10-day RSI is more likely to reach overbought or oversold levels than
    20-day RSI. The look-back parameters also depend on a security's
    volatility.

    Like many momentum oscillators, overbought and oversold readings for RSI
    work best when prices move sideways within a range.

    You can also look for divergence with price.
    If the price has new highs/lows, and the RSI hasn't, expect a reversal.
    Signals can also be generated by looking for failure swings and centerline
    crossovers.

    RSI can also be used to identify the general trend.

    The RSI was developed by J. Welles Wilder and was first introduced in his
    article in the June, 1978 issue of Commodities magazine, now known as
    Futures magazine. It is detailed in his book New Concepts In Technical
    Trading Systems.

    http://www.csidata.com/?page_id=797
    http://stockcharts.com/help/doku.php?id=chart_school:technical_indicators:relative_strength_in

    Input:
      prices ndarray
      period int > 1 and < len(prices) (optional and defaults to 14)

    Output:
      rsis ndarray

    Test:

     import numpy as np
     import technical_indicators as tai
     prices = np.array([44.55, 44.3, 44.36, 43.82, 44.46, 44.96, 45.23,
    ... 45.56, 45.98, 46.22, 46.03, 46.17, 45.75, 46.42, 46.42, 46.14, 46.17,
    ... 46.55, 46.36, 45.78, 46.35, 46.39, 45.85, 46.59, 45.92, 45.49, 44.16,
    ... 44.31, 44.35, 44.7, 43.55, 42.79, 43.26])
     print(tai.rsi(prices))
    [ 70.02141328  65.77440817  66.01226849  68.95536568  65.88342192
      57.46707948  62.532685    62.86690858  55.64975092  62.07502976
      54.39159393  50.10513101  39.68712141  41.17273382  41.5859395
      45.21224077  37.06939108  32.85768734  37.58081218]
    """

    num_prices = len(prices)

    if num_prices < period:
        # show error message
        raise SystemExit('Error: num_prices < period')

    # this could be named gains/losses to save time/memory in the future

    print "CHANGES:",prices[1:], prices[:-1]
    changes = prices[1:] - prices[:-1]
    #num_changes = len(changes)

    rsi_range = num_prices - period

    print "RSI_RANGE:",rsi_range
    rsis = np.zeros(rsi_range)

    gains = np.array(changes)
    # assign 0 to all negative values
    masked_gains = gains < 0
    gains[masked_gains] = 0

    losses = np.array(changes)
    # assign 0 to all positive values
    masked_losses = losses > 0
    losses[masked_losses] = 0
    # convert all negatives into positives
    losses *= -1

    avg_gain = np.mean(gains[:period])
    avg_loss = np.mean(losses[:period])

    if avg_loss == 0:
        rsis[0] = 100
    else:
        rs = avg_gain / avg_loss
        print "RS:",rs
        rsis[0] = 100 - (100 / (1 + rs))

    for idx in range(1, rsi_range):
        avg_gain = ((avg_gain * (period - 1) + gains[idx + (period - 1)]) /
                    period)
        avg_loss = ((avg_loss * (period - 1) + losses[idx + (period - 1)]) /
                    period)

        if avg_loss == 0:
            rsis[idx] = 100
        else:
            rs = avg_gain / avg_loss
            rsis[idx] = 100 - (100 / (1 + rs))

    return rsis

def queue_to_list(q):
    """ Dump a Queue to a list """

    # A new list
    l = []

    while len(q) > 0:
        l.append(q.get())
    return l

class TDSequential(AbstractIndicator):
    """
    A testing strategy that simply purchases (longs) a set of
    assets upon first receipt of the relevant bar event and
    then holds until the completion of a backtest.
    """
    def __init__(self, tickers, events_queue, indicator_details):
        self.tickers = tickers
        self.events_queue = events_queue
        self.ticks = 0
        self.invested = False
        self.period = indicator_details['window']
        self.q = deque(maxlen= self.period+1)

    def getSignal(self, ticker):
        return SignalEvent(self.tickers[0], "BOT")

    def updateIndicators(self, event, agent=None):

        ticker = self.tickers[0]
        if event.type in [EventType.BAR, EventType.TICK] and event.ticker == ticker:

            print " Received event for TDSequential update:",self.period
            print event.adj_close_price
            self.q.append(event.adj_close_price)
            if len(self.q)  == self.q.maxlen  :
                ll = list(self.q)
                print " LIST:",ll
                print rsi( np.array(ll))
            self.ticks += 1
            print self.q



if __name__ == '__main__':

    q = deque(maxlen=2)

    q.append(1)
    q.append(2)
    q.append(3)

    print len(q), q

    print list(q)

    prices = np.array([44.55, 44.3, 44.36, 43.82, 44.46, 44.96, 45.23,
                        45.56, 45.98, 46.22, 46.03, 46.17, 45.75, 46.42, 55.00])
    print rsi(prices)
    nn = np.array (q)
    print nn[1:]