from environment.event import (SignalEvent, EventType)
from collections import deque
from AbstractIndicator import AbstractIndicator
import numpy as np
import random


def rsi(prices, period=14):
    """
    The Relative Strength Index (RSI) is a momentum oscillator.
    It oscillates between 0 and 100.
    It is considered overbought/oversold when it's over 70/below 30.
    Some traders use 80/20 to be on the safe side.
    RSI becomes more accurate as the calculation period (min_periods)
    increases.
    This can be lowered to increase sensitivity or raised to decrease
    sensitivity.
    10-day RSI is more likely to reach overbought or oversold levels than
    20-day RSI. The look-back parameters also depend on a security's
    volatility.

    Like many momentum oscillators, overbought and oversold readings for RSI
    work best when prices move sideways within a range.

    You can also look for divergence with price.
    If the price has new highs/lows, and the RSI hasn't, expect a reversal.
    Signals can also be generated by looking for failure swings and centerline
    crossovers.

    RSI can also be used to identify the general trend.

    The RSI was developed by J. Welles Wilder and was first introduced in his
    article in the June, 1978 issue of Commodities magazine, now known as
    Futures magazine. It is detailed in his book New Concepts In Technical
    Trading Systems.

    http://www.csidata.com/?page_id=797
    http://stockcharts.com/help/doku.php?id=chart_school:technical_indicators:relative_strength_in

    Input:
      prices ndarray
      period int > 1 and < len(prices) (optional and defaults to 14)

    Output:
      rsis ndarray

    Test:

     import numpy as np
     import technical_indicators as tai
     prices = np.array([44.55, 44.3, 44.36, 43.82, 44.46, 44.96, 45.23,
    ... 45.56, 45.98, 46.22, 46.03, 46.17, 45.75, 46.42, 46.42, 46.14, 46.17,
    ... 46.55, 46.36, 45.78, 46.35, 46.39, 45.85, 46.59, 45.92, 45.49, 44.16,
    ... 44.31, 44.35, 44.7, 43.55, 42.79, 43.26])
     print(tai.rsi(prices))
    [ 70.02141328  65.77440817  66.01226849  68.95536568  65.88342192
      57.46707948  62.532685    62.86690858  55.64975092  62.07502976
      54.39159393  50.10513101  39.68712141  41.17273382  41.5859395
      45.21224077  37.06939108  32.85768734  37.58081218]
    """

    num_prices = len(prices)

    if num_prices < period:
        # show error message
        raise SystemExit('Error: num_prices < period')

    # this could be named gains/losses to save time/memory in the future

    print "CHANGES:",prices[1:], prices[:-1]
    changes = prices[1:] - prices[:-1]
    #num_changes = len(changes)

    rsi_range = num_prices - period

    print "RSI_RANGE:",rsi_range
    rsis = np.zeros(rsi_range)

    gains = np.array(changes)
    # assign 0 to all negative values
    masked_gains = gains < 0
    gains[masked_gains] = 0

    losses = np.array(changes)
    # assign 0 to all positive values
    masked_losses = losses > 0
    losses[masked_losses] = 0
    # convert all negatives into positives
    losses *= -1

    avg_gain = np.mean(gains[:period])
    avg_loss = np.mean(losses[:period])

    if avg_loss == 0:
        rsis[0] = 100
    else:
        rs = avg_gain / avg_loss
        print "RS:",rs
        rsis[0] = 100 - (100 / (1 + rs))

    for idx in range(1, rsi_range):
        avg_gain = ((avg_gain * (period - 1) + gains[idx + (period - 1)]) /
                    period)
        avg_loss = ((avg_loss * (period - 1) + losses[idx + (period - 1)]) /
                    period)

        if avg_loss == 0:
            rsis[idx] = 100
        else:
            rs = avg_gain / avg_loss
            rsis[idx] = 100 - (100 / (1 + rs))

    return rsis

def queue_to_list(q):
    """ Dump a Queue to a list """

    # A new list
    l = []

    while len(q) > 0:
        l.append(q.get())
    return l

class RSI14(AbstractIndicator):
    """
    A testing strategy that simply purchases (longs) a set of
    assets upon first receipt of the relevant bar event and
    then holds until the completion of a backtest.
    """
    def __init__(self, tickers, events_queue, indicator_details):
        self.tickers = tickers
        self.events_queue = events_queue
        self.ticks = 0
        self.invested = False
        self.period = indicator_details['window']
        self.q = deque(maxlen= self.period+1)

    def getSignal(self, ticker):
        return SignalEvent(self.tickers[0], "BOT")

    def updateIndicators(self, event, agent=None):

        ticker = self.tickers[0]
        if event.type in [EventType.BAR, EventType.TICK] and event.ticker == ticker:

            print " Received event for RSI14 update:",self.period
            print event.adj_close_price
            self.q.append(event.adj_close_price)
            if len(self.q)  == self.q.maxlen  :
                ll = list(self.q)
                print "RSI14 LIST:",ll
                print rsi( np.array(ll))
            self.ticks += 1
            print self.q

class RSI50(AbstractIndicator):
    """
    A testing strategy that simply purchases (longs) a set of
    assets upon first receipt of the relevant bar event and
    then holds until the completion of a backtest.
    """
    def __init__(self, tickers, events_queue, indicator_details):
        self.tickers = tickers
        self.events_queue = events_queue
        self.ticks = 0
        self.invested = False
        self.period = indicator_details['window']
        self.q = deque(maxlen= self.period+1)

    def getSignal(self, ticker):
        return SignalEvent(self.tickers[0], "BOT")

    def updateIndicators(self, event, agent=None):

        ticker = self.tickers[0]
        if event.type in [EventType.BAR, EventType.TICK] and event.ticker == ticker:
            print event.adj_close_price
            self.q.append(event.adj_close_price)
            if len(self.q)  == self.q.maxlen  :
                ll = list(self.q)
                print "LIST:",ll
                print rsi( np.array(ll))
            self.ticks += 1
            print self.q




class movingAverage(AbstractIndicator):
    """
    A testing strategy that simply purchases (longs) a set of
    assets upon first receipt of the relevant bar event and
    then holds until the completion of a backtest.
    """
    def __init__(self, tickers, events_queue, indicator_details):

        short_window = 100
        long_window = 400

        self.tickers = tickers
        self.events_queue = events_queue
        self.short_window = short_window
        self.long_window = long_window
        self.bars = 0
        self.invested = False

        self.sw_bars = dict()
        self.lw_bars = dict()
        self.signal = dict()

        self.tickers = tickers
        self.events_queue = events_queue
        self.ticks = 0

        self.period = indicator_details['window']

        for ticker in tickers :
            self.sw_bars[ticker] = deque(maxlen=self.short_window)
            self.lw_bars[ticker] = deque(maxlen=self.long_window)

        for ticker in tickers :
         self.signal[ticker] = "NONE"


    def getSignal(self, ticker):
        print "TIC", ticker, self.signal
        return SignalEvent(ticker, self.signal[ticker])

    def updateIndicators(self, event, agent=None):

        if event.type in [EventType.BAR, EventType.TICK] and event.ticker in self.tickers :

            self.lw_bars[event.ticker].append(event.adj_close_price)
            self.sw_bars[event.ticker].append(event.adj_close_price)


            # Enough bars are present for trading
            if len(self.lw_bars[event.ticker]) == self.lw_bars[event.ticker].maxlen:
                # Calculate the simple moving averages
                short_sma = np.mean(self.sw_bars[event.ticker])
                long_sma = np.mean(self.lw_bars[event.ticker])
                # Trading signals based on moving average cross
                if short_sma > long_sma and not self.invested:
                    print("LONG: %s" % event.time)
                    self.signal[event.ticker] = "BOT"

                elif short_sma < long_sma and self.invested:
                    print("SHORT: %s" % event.time)
                    self.signal[event.ticker] = "EXIT"

            self.ticks += 1



class DailyValueChangeCalculator(AbstractIndicator):
    """
    A testing strategy that simply purchases (longs) a set of
    assets upon first receipt of the relevant bar event and
    then holds until the completion of a backtest.
    """
    def __init__(self, tickers, events_queue, indicator_details):
        self.tickers = tickers
        self.events_queue = events_queue
        self.ticks = 0
        self.invested = False
        self.period = indicator_details['window']
        self.q = deque(maxlen= self.period+1)

    def getSignal(self, ticker):
        return random.choice(list([0.5, 0.8, 2, 1, 0.2, 0.7, 2, 3]))

    def updateIndicators(self, event, agent=None):

        print "Inside DailyValueChangeCalculator:updateIndicators"
        ticker = self.tickers[0]
        if event.type in [EventType.BAR, EventType.TICK] and event.ticker == ticker:
            print event.adj_close_price
            self.q.append(event.adj_close_price)
            if len(self.q)  == self.q.maxlen  :
                ll = list(self.q)
                print " LIST:",ll
                print rsi( np.array(ll))
            self.ticks += 1
            print self.q


class MonthlyValueChangeCalculator(AbstractIndicator):
    """
    A testing strategy that simply purchases (longs) a set of
    assets upon first receipt of the relevant bar event and
    then holds until the completion of a backtest.
    """
    def __init__(self, tickers, events_queue, indicator_details):
        self.tickers = tickers
        self.events_queue = events_queue
        self.ticks = 0
        self.invested = False
        self.period = indicator_details['window']
        self.q = deque(maxlen= self.period+1)

    def getSignal(self, ticker):
        return random.choice(list([7, 8, 2, 1, 0.5, 0.7, 2, 3, 1.5]))

    def updateIndicators(self, event, agent=None):
        print "Inside MonthlyValueChangeCalculator:updateIndicators"
        ticker = self.tickers[0]
        if event.type in [EventType.BAR, EventType.TICK] and event.ticker == ticker:

            print event.adj_close_price
            self.q.append(event.adj_close_price)
            if len(self.q)  == self.q.maxlen  :
                ll = list(self.q)
                print " LIST:",ll
                print rsi( np.array(ll))
            self.ticks += 1
            print self.q


class WeeklyValueChangeCalculator(AbstractIndicator):
    """
    A testing strategy that simply purchases (longs) a set of
    assets upon first receipt of the relevant bar event and
    then holds until the completion of a backtest.
    """
    def __init__(self, tickers, events_queue, indicator_details):
        self.tickers = tickers
        self.events_queue = events_queue
        self.ticks = 0
        self.invested = False
        self.period = indicator_details['window']
        self.q = deque(maxlen= self.period+1)

    def getSignal(self, ticker):
        return random.choice(list([7, 8, 2, 1, 0.5, 0.7, 2, 3, 1.5]))

    def updateIndicators(self, event, agent=None):
        print "Inside WeeklyValueChangeCalculator:updateIndicators"
        ticker = self.tickers[0]
        if event.type in [EventType.BAR, EventType.TICK] and event.ticker == ticker:

            print " Received event for RSI50 update:",self.period
            print event.adj_close_price
            self.q.append(event.adj_close_price)
            if len(self.q)  == self.q.maxlen  :
                ll = list(self.q)
                print "RSI50 LIST:",ll
                print rsi( np.array(ll))
            self.ticks += 1
            print self.q

class QuaterlyValueChangeCalculator(AbstractIndicator):
    """
    A testing strategy that simply purchases (longs) a set of
    assets upon first receipt of the relevant bar event and
    then holds until the completion of a backtest.
    """
    def __init__(self, tickers, events_queue, indicator_details):
        self.tickers = tickers
        self.events_queue = events_queue
        self.ticks = 0
        self.invested = False
        self.period = indicator_details['window']
        self.q = deque(maxlen= self.period+1)

    def getSignal(self, ticker):
        return random.choice(list([7, 8, 2, 1, 0.5, 0.7, 2, 3, 1.5]))

    def updateIndicators(self, event, agent=None):
        print "Inside QuaterlyValueChangeCalculator:updateIndicators"
        ticker = self.tickers[0]
        if event.type in [EventType.BAR, EventType.TICK] and event.ticker == ticker:

            print " Received event for RSI50 update:",self.period
            print event.adj_close_price
            self.q.append(event.adj_close_price)
            if len(self.q)  == self.q.maxlen  :
                ll = list(self.q)
                print "RSI50 LIST:",ll
                print rsi( np.array(ll))
            self.ticks += 1
            print self.q
class RSICrossOver(AbstractIndicator):
    """
    A testing strategy that simply purchases (longs) a set of
    assets upon first receipt of the relevant bar event and
    then holds until the completion of a backtest.
    """
    def __init__(self, tickers, events_queue, indicator_details):

        self.tickers = tickers
        self.events_queue = events_queue
        self.ticks = 0
        self.invested = False

    def getSignal(self, ticker):
        return SignalEvent(self.tickers[0], "BOT")

    def updateIndicators(self, event, agent=None):
        ticker = self.tickers[0]
        if event.type in [EventType.BAR, EventType.TICK] and event.ticker == ticker:
            print " Received eventRSICrossOver RSI update:"
            print event.adj_close_price

            self.ticks += 1

if __name__ == '__main__':

    q = deque(maxlen=2)

    q.append(1)
    q.append(2)
    q.append(3)

    print len(q), q

    print list(q)

    prices = np.array([44.55, 44.3, 44.36, 43.82, 44.46, 44.96, 45.23,
                        45.56, 45.98, 46.22, 46.03, 46.17, 45.75, 46.42, 55.00])
    print rsi(prices)
    nn = np.array (q)
    print nn[1:]